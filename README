AWK library function descriptions

POSIX compliant functions are marked with a "*", and have been tested on
gawk 3 and 4, as well as nawk 20110810. Functions marked with "**" have also
been tested on mawk 1.3.4, which is not fully POSIX compliant. The markings next
to the library name indicate the lowest level of compliance of all of the
functions within. Interval notation has not been used in the functions in this
library, even though POSIX states that they should be supported, because most
current implementations of awk still do not support them.

Note: mawk 1.3.3 is even less POSIX compliant than 1.3.4, and doesn't handle
POSIX character classes in regexes (like [:space:] or [:alpha:]), among other
things. It is currently the standard on ubuntu, and is most likely standard on
other debian-based linux distributions, as well. Even functions marked with
'**' are not guaranteed to work on versions of mawk prior to 1.3.4, although
they should not be too hard to alter in order to do so. (The biggest issue is
split(str, arr, //) ).

If you are using gawk, I recommend adding the location of this repo to the
AWKPATH environment variable. This will allow you to only supply the file name
to -f and @include, instead of having to supply the actual path to the library.


The 'examples' directory includes a sample script for each library, with sample
usage of each function. While most of the examples are solely there to give
examples, the "cfold" script is fully functioning and is (in my opinion) rather
useful. It shows just how powerful these libraries can be... most of the script
is just there to parse options. These examples are written with gawk extensions.
Making them POSIX is left as an exercise to the user, if desired.





Libraries, and the available functions within:

math.awk **

  ceil(multiple, number) **
    returns "number" rounded UP to the nearest multiple of "multiple". integers
    only

  floor(multiple, number) **
    returns "number" rounded DOWN to the nearest multiple of "multiple".
    integers only

  round(multiple, number) **
    returns "number" rounded to the nearest multiple of "multiple". integers
    only

  change_base(number, start_base, end_base) **
    converts "number" from "start_base" to "end_base"
    bases must be between 2 and 64. the digits greater than 9 are represented
    by the lowercase letters, the uppercase letters, @, and _, in that order.
    if ibase is less than or equal to 36, lowercase and uppercase letters may
    be used interchangeably to represent numbers between 10 and 35. integers
    only. returns 0 if any argument is invalid

  calc_e() **
    approximates e by calculating the sumation from k=0 to k=50 of 1/k!
    returns 10 decimal places

  calc_pi() **
    returns pi, with an accuracy of 10 decimal places

  calc_tau() **
    returns tau, with an accuracy of 10 decimal places
    http://tauday.com/tau-manifesto

  deg_to_rad(degrees) **
    converts degrees to radians

  rad_to_deg(radians) **
    converts radians to degrees

  tan(expr) **
    returns the tangent of expr, which is in radians

  csc(expr) **
    returns the cosecant of expr, which is in radians

  sec(expr) **
    returns the secant of expr, which is in radians

  cot(expr) **
    returns the cotangent of expr, which is in radians



strings.awk *

  center(string[, width]) **
    returns "string" centered based on "width". if "width" is not provided (or 
    is 0), uses the width of the terminal, or 80 if standard output is not open
    on a terminal.
    note: does not check the length of the string. if it's wider than the
    terminal, it will not center lines other than the first. for best results,
    combine with fold() (see the "cfold" script in the "examples" directory for
    a script that does exactly this!)

  delete_arr(array) **
    deletes every element in "array"

  fold(string, sep[, width]) *
    returns "string", wrapped, with lines broken on "sep" to "width" columns.
    "sep" is a list of characters to break at, similar to IFS in a POSIX shell.
    if "sep" is empty, wraps at exactly "width" characters. if "width" is not
    provided (or is 0), uses the width of the terminal, or 80 if standard output
    is not open on a terminal.
    note: currently, tabs are squeezed to a single space. this will be fixed

  shell_escape(string) **
    returns the string escaped so that it can be used in a shell command

  ssub(ere, repl [, in]) **
    behaves like sub, except returns the result and doesn't modify "in".
    note: 'ere' must not use /.../ literal regex quoting

  sgsub(ere, repl [, in]) **
    behaves like gsub, except returns the result and doesn't modify "in".
    note: 'ere' must not use /.../ literal regex quoting

  lsub(str, repl [, in]) **
    substites the string "repl" in place of the first instance of "str" in the
    string "in" and returns the result. does not modify the original string. if
    "in" is not provided, uses $0

  glsub(str, repl [, in]) **
    behaves like lsub, except it replaces all occurances of "str"
    note: does not work in mawk when 'str' is empty

  str_to_arr(string, array) *
    converts string to an array, one char per element, 1-indexed
    returns the array length

  trim(string) **
    returns "string" with leading and trailing whitespace trimmed

  rev(string) *
    returns "string" backwards



csv.awk *

  create_line(array, max [, sep [, qualifier] ]) **
    Generates an output line in quoted CSV format, from the contents of "array"
    "array" is expected to be an indexed array (1-indexed). "max" is the highest
    index to be used. "sep", if provided, is the field separator. If it is more
    than one character, the first character in the string is used. By default,
    it is a comma. "qualifier", if provided, is the quote character. Like "sep",
    it is one character. The default value is `"'. For example, the array:
    a[1]="foo"; a[2]="bar,quux"; a[3]="blah\"baz", when called with
    create_line(a, 3), will return: "foo","bar,quux","blah""baz".
    note: expects a non-sparse array. empty or unset values will become
    empty fields

  qsplit(string, array [, sep [, qualifier] ]) *
    a version of split() designed for CSV-like data. splits "string" on "sep"
    (,) if not provided, into array[1], array[2], ... array[n]. returns "n".
    both "sep" and "qualifier" will use the first character in the provided
    string. uses "qualifier" (" if not provided) and ignores "sep" within
    quoted fields. doubled qualifiers are considered escaped, and a single 
    qualifier character is used in its place.
    for example, foo,"bar,baz""blah",quux will be split as such:
    array[1] = "foo"; array[2] = "bar,baz\"blah"; array[3] = "quux";



options.awk **

  getopts(optstring [, longopt_array ]) **
    parses options, and deletes them from ARGV. "optstring" is of the form
    "ab:c". each letter is a possible option. if the letter is followed by a
    colon (:), then the option requires an argument. if an argument is not
    provided, or an invalid option is given, getopts will print the appropriate
    error message and return "?". returns each option as it's read, and -1 when
    no options are left. "optind" will be set to the index of the next
    non-option argument when finished.  "optarg" will be set to the option's
    argument, when provided. if not provided, "optarg" will be empty. "optname"
    will be set to the current option, as provided. getopts will delete each
    option and argument that it successfully reads, so awk will be able to treat
    whatever's left as filenames/assignments, as usual. if provided,
    "longopt_array" is the name of an associative array that maps long options
    to the appropriate short option. (do not include the hyphens on either).
    sample usage can be found in the examples dir, with gawk extensions, or in
    the ogrep script for a POSIX example: https://github.com/e36freak/ogrep



times.awk **

  month_to_num(month) **
    converts human readable month to the decimal representation
    returns the number, -1 if the month doesn't exist

  day_to_num(day) **
    converts human readable day to the decimal representation
    returns the number, -1 if the day doesn't exist

  hr_to_sec(timestamp) **
    converts HH:MM:SS to seconds, returns -1 if invalid format

  sec_to_hr(seconds) **
    converts seconds to HH:MM:SS





Copywrite Daniel Mills <danielmills1@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
