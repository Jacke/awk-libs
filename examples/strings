#!/usr/bin/awk -f

# include library. gawk can use AWKPATH so the actual path isn't needed, see
# the man page (since the path is relative, this assumes the lib dir is in
# AWKPATH or the same dir)
@include "strings.awk";

# usage: center(string[, width])
# returns "string" centered based on "width". if "width" is not provided (or 
# is 0), uses the width of the terminal, or 80 if standard output is not open
# on a terminal.
# note: does not check the length of the string. if it's wider than the
# terminal, it will not center lines other than the first. for best results,
# combine with fold().
BEGIN {
  print center("this string is centered");

  print "";
}

# usage: fold(string, sep[, width])
# returns "string", wrapped, with lines broken on "sep" to "width" columns.
# "sep" is a list of characters to break at, similar to IFS in a POSIX shell.
# if "sep" is empty, wraps at exactly "width" characters. if "width" is not
# provided (or is 0), uses the width of the terminal, or 80 if standard output
# is not open on a terminal.
# note: currently, tabs are squeezed to a single space. this will be fixed
BEGIN {
  # folds the alphabet on vowels, to 12 and 15 characters
  alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

  print "alphabet, folded to 12 characters on vowels:";
  print "";
  print fold(alphabet, "AEIOU", 12);
  print "";

  print "alphabet, folded to 15 characters on vowels:";
  print "";
  print fold(alphabet, "AEIOU", 15);
  print "";
}

# usage: ssub(ere, repl[, in])
# behaves like sub, except returns the result and doesn't modify the original
BEGIN {
  string = "this is some string";

  print "ssub: ";
  print "";

  print string;
  print ssub("str.*", "replaced &", string);
  print string;

  print "";
}

# usage: sgsub(ere, repl[, in])
# behaves like gsub, except returns the result and doesn't modify the original
BEGIN {
  string = "this is some search string search";

  print "sgsub: ";
  print "";

  print string;
  print sgsub("search", "replace", string);
  print string;

  print "";
}

# usage: lsub(str, repl [, in])
# substites the string "repl" in place of the first instance of "str" in the
# string "in" and returns the result. does not modify the original string.
# if "in" is not provided, uses $0.
BEGIN {
  string = "string with special .* characters";

  print "lsub: ";
  print "";

  print string;
  print lsub(".*", "literal", string);
  print string;

  print "";
}

# usage: glsub(str, repl [, in])
# behaves like lsub, except it replaces all occurances of "str"
BEGIN {
  string = "string with .* special .* characters";

  print "glsub: ";
  print "";

  print string;
  print glsub(".*", "literal", string);
  print string;

  print "";
}

# usage: shell_esc(string)
# returns the string escaped so that it can be used in a shell command
BEGIN {
  file = "some 'filename' with * special characters to be used in system()";

  print "shell escape:"
  print "";
  print "first is normal, second escaped: ";
  print file;
  print shell_esc(file);
  print "";
}

# usage: str_to_arr(string, array)
# converts string to an array, one char per element, 1-indexed
# returns the array length
BEGIN {
  string = "some string";

  print "str_to_arr:";
  print "";

  print "initial string: ";
  print string;
  print "";

  print "one character per line:"
  len = str_to_arr(string, array);

  for (i=1; i<=len; i++) {
    print array[i];
  }

  print "";
}

# usage: fwidths(width_spec [, string]) **
# extracts substrings from "string" according to "width_spec" from left to
# right and assigns them to $1, $2, etc. also assigns the NF variable. if
# "string" is not supplied, uses $0. "width_spec" is a space separated list of
# numbers that specify field widths, just like GNU awk's FIELDWIDTHS variable.
# returns the value for NF.
BEGIN {
  str = "1234567890";
  fwidths("3 2 5", str);

  for (i=1; i<=NF; i++) {
    print $i;
  }

  print "";
}

# usage: fwidths_arr(width_spec, array [, string]) **
# the behavior is the same as that of fwidths(), except that the values are
# assigned to "array", indexed with sequential integers starting with 1.
# returns the length. everything else is described in fwidths() above.
BEGIN {
  str = "1234567890";
  len = fwidths("2 1 4 3", a, str);

  for (i=1; i<=len; i++) {
    print a[i];
  }

  print "";
}

# usage: trim(string)
# returns "string" with leading and trailing whitespace trimmed
BEGIN {
  string = "      whitespace      ";

  print "normal: <" string ">";
  print "after trim(): <" trim(string) ">";

  print "";
}

# usage: rev(string)
# returns "string" backwards
BEGIN {
  string = "forwards";

  print "normal: " string;
  print "after rev(): " rev(string);
}
